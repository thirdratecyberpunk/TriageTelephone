{
  "_from": "passport-azure-ad",
  "_id": "passport-azure-ad@3.0.12",
  "_inBundle": false,
  "_integrity": "sha1-hkBV/+hEd9v6B1uQNEY84obw5ME=",
  "_location": "/passport-azure-ad",
  "_phantomChildren": {
    "passport-strategy": "1.0.0",
    "pause": "0.0.1"
  },
  "_requested": {
    "escapedName": "passport-azure-ad",
    "fetchSpec": "latest",
    "name": "passport-azure-ad",
    "raw": "passport-azure-ad",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/passport-azure-ad/-/passport-azure-ad-3.0.12.tgz",
  "_shasum": "864055ffe84477dbfa075b9034463ce286f0e4c1",
  "_spec": "passport-azure-ad",
  "_where": "C:\\Users\\Jenny\\Finally node\\TriageTelephone",
  "author": {
    "email": "nugetaad@microsoft.com",
    "name": "azuread",
    "url": "http://microsoft.com/"
  },
  "bugs": {
    "url": "https://github.com/AzureAD/passport-azure-ad/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "async": "^1.5.2",
    "base64url": "^2.0.0",
    "bunyan": "^1.8.0",
    "cache-manager": "^2.0.0",
    "jwk-to-pem": "^1.2.6",
    "jws": "^3.1.3",
    "lodash": "^4.11.2",
    "oauth": "0.9.14",
    "passport": "^0.3.2",
    "request": "^2.72.0",
    "valid-url": "^1.0.6"
  },
  "deprecated": false,
  "description": "OIDC and Bearer Passport strategies for Azure Active Directory",
  "devDependencies": {
    "chai": "2.x.x",
    "chai-passport-strategy": "1.x.x",
    "grunt": "^1.0.1",
    "grunt-contrib-nodeunit": "^1.0.0",
    "grunt-mocha-test": "^0.12.7",
    "mocha": "^3.0.2",
    "nodeunit": "^0.9.1"
  },
  "engines": {
    "node": ">= 4.0.1"
  },
  "homepage": "https://github.com/AzureAD/passport-azure-ad#readme",
  "keywords": [
    "aad",
    "adfs",
    "azure active directory",
    "bearer",
    "oidc",
    "shibboleth",
    "sso"
  ],
  "license": "MIT",
  "main": "./lib",
  "name": "passport-azure-ad",
  "optionalDependencies": {},
  "readme": "\n# Microsoft Azure Active Directory Passport.js Plug-In\n\n---\n\n_passport-azure-ad_ is a collection of [Passport](http://passportjs.org/) Strategies \nto help you integrate with Azure Active Directory. It includes OpenID Connect, \nWS-Federation, and SAML-P authentication and authorization. These providers let you \nintegrate your Node app with Microsoft Azure AD so you can use its many features, \nincluding web single sign-on (WebSSO), Endpoint Protection with OAuth, and JWT token \nissuance and validation.\n\n_passport-azure-ad_ has been tested to work with both [Microsoft Azure Active Directory](https://azure.microsoft.com/en-us/services/active-directory/) \nand with [Microsoft Active Directory Federation Services](http://en.wikipedia.org/wiki/Active_Directory_Federation_Services).\n\n## 1. Security Vulnerability in Versions < 1.4.6 and 2.0.0\n_passport-azure-ad_ has a known security vulnerability affecting versions <1.4.6 and 2.0.0. Please update to >=1.4.6 or >=2.0.1 immediately. For more details, see the [security notice](https://github.com/AzureAD/passport-azure-ad/blob/master/SECURITY-NOTICE.MD).\n\n## 2. Versions\nCurrent version - 3.0.12  \nMinimum  recommended version - 1.4.6  \nYou can find the changes for each version in the [change log](https://github.com/AzureAD/passport-azure-ad/blob/master/CHANGELOG.md).\n\n## 3. Contribution History\n\n[![Stories in Ready](https://badge.waffle.io/AzureAD/passport-azure-ad.png?label=ready&title=Ready)](https://waffle.io/AzureAD/passport-azure-ad)\n\n[![Throughput Graph](https://graphs.waffle.io/AzureAD/passport-azure-ad/throughput.svg)](https://waffle.io/AzureAD/passport-azure-ad/metrics)\n\n## 4. Installation\n\n    $ npm install passport-azure-ad\n\n## 5. Usage\n\nThis library contains two strategies: OIDCStrategy and BearerStrategy.\n\nOIDCStrategy uses OpenID Connect protocol for web application login purposes. It works in the following manner:\nIf a user is not logged in, passport sends an authentication request to AAD (Azure Active Directory), and AAD prompts the user for his or her sign-in credentials. On successful authentication, depending on the flow you choose, web application will eventually get an id_token back either directly from the AAD authorization endpoint or by redeeming a code at the AAD token endpoint. Passport then validates the id_token and propagates the claims in id_token back to the verify callback, and let the framework finish the remaining authentication procedure. If the whole process is successful, passport adds the user information to `req.user` and passes it to the next middleware. In case of error, passport either sends back an unauthorized response or redirects the user to the page you specified (such as homepage or login page).\n\nBearerStrategy uses Bearer Token protocol to protect web resource/api. It works in the following manner:\nUser sends a request to the protected web api which contains an access_token in either the authorization header or body. Passport extracts and validates the access_token, and propagates the claims in access_token to the verify callback and let the framework finish the remaining authentication procedure. On successful authentication, passport adds the user information to `req.user` and passes it to the next middleware, which is usually the business logic of the web resource/api. In case of error, passport sends back an unauthorized response.\n\n\nWe support AAD v1, v2 and B2C tenants for both strategies. Please check out section 7 for the samples. You can manage v1 tenants and register applications at https://manage.windowsazure.com. For v2 tenants and applications, you should go to https://apps.dev.microsoft.com. For B2C tenants, go to https://manage.windowsazure.com and click 'Manage B2C settings' to register applications and policies. \n\n### 5.1 OIDCStrategy\n\n#### 5.1.1 Configure strategy and provide callback function\n\n##### 5.1.1.1 Sample using the OIDCStrategy\n\n```javascript\npassport.use(new OIDCStrategy({\n    identityMetadata: config.creds.identityMetadata,\n    clientID: config.creds.clientID,\n    responseType: config.creds.responseType,\n    responseMode: config.creds.responseMode,\n    redirectUrl: config.creds.redirectUrl,\n    allowHttpForRedirectUrl: config.creds.allowHttpForRedirectUrl,\n    clientSecret: config.creds.clientSecret,\n    validateIssuer: config.creds.validateIssuer,\n    isB2C: config.creds.isB2C,\n    issuer: config.creds.issuer,\n    passReqToCallback: config.creds.passReqToCallback,\n    scope: config.creds.scope,\n    loggingLevel: config.creds.loggingLevel,\n    loggingNoPII: config.creds.loggingNoPII,\n    nonceLifetime: config.creds.nonceLifetime,\n    nonceMaxAmount: config.creds.nonceMaxAmount,\n    useCookieInsteadOfSession: config.creds.useCookieInsteadOfSession,\n    cookieEncryptionKeys: config.creds.cookieEncryptionKeys,\n    clockSkew: config.creds.clockSkew,\n  },\n  function(iss, sub, profile, accessToken, refreshToken, done) {\n    if (!profile.oid) {\n      return done(new Error(\"No oid found\"), null);\n    }\n    // asynchronous verification, for effect...\n    process.nextTick(function () {\n      findByOid(profile.oid, function(err, user) {\n        if (err) {\n          return done(err);\n        }\n        if (!user) {\n          // \"Auto-registration\"\n          users.push(profile);\n          return done(null, profile);\n        }\n        return done(null, user);\n      });\n    });\n  }\n));\n```\n\n##### 5.1.1.2 Options\n\n* `identityMetadata` (Required)\n\n  The metadata endpoint provided by the Microsoft Identity Portal that provides the keys and other important information at runtime.    Examples:\n  * v1 tenant-specific endpoint\n  ```\n    https://login.microsoftonline.com/your_tenant_name.onmicrosoft.com/.well-known/openid-configuration\n    https://login.microsoftonline.com/your_tenant_guid/.well-known/openid-configuration\n  ```\n  * v1 common endpoint\n  ```\n    https://login.microsoftonline.com/common/.well-known/openid-configuration\n  ```\n  * v2 tenant-specific endpoint\n  ```\n    https://login.microsoftonline.com/your_tenant_name.onmicrosoft.com/v2.0/.well-known/openid-configuration \n    https://login.microsoftonline.com/your_tenant_guid/v2.0/.well-known/openid-configuration\n  ```\n  * v2 common endpoint\n  ``` \n    https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration\n  ```\n  \n  For B2C, you cannot use v2 common endpoint unless you specify the tenant in `passport.authenticate` using `tenantIdOrName` option. See section 5.1.3 for more details.\n  \n* `clientID` (Required)\n\n  The client ID of your application in AAD (Azure Active Directory)\n  \n* `responseType` (Required)\n  \n  Must be 'code', 'code id_token', 'id_token code' or 'id_token'. For login only flows you can use 'id_token'; if you want access_token, use 'code', 'code id_token' or 'id_token code'.\n\n* `responseMode` (Required)\n  \n  Must be 'query' or 'form_post'. This is how you get code or id_token back. 'form_post' is recommended for all scenarios.\n  \n* `redirectUrl`  (Required)\n  \n  Must be a https url string, unless you set `allowHttpForRedirectUrl` to true. This is the reply URL registered in AAD for your app. Production environment should always use https for `redirectUrl`.\n\n* `passReqToCallback`  (Required)\n\n  Whether you want to use `req` as the first parameter in the verify callback. See section 5.1.1.3 for more details.\n\n* `allowHttpForRedirectUrl`  (Conditional) \n  \n  Required to set to true if you want to use http url for redirectUrl like `http://localhost:3000`. \n \n* `clientSecret`  (Conditional)\n\n  When `responseType` is not `id_token`, we have to provide client credential to redeem the authorization code. This credential could be client secret or client assertion. Non-B2C tenant supports both flows, but B2C tenant only supports client secret flow.\n  \n  For B2C tenant: `clientSecret` is required if the `responseType` is not 'id_token'.\n\n  For non-B2C tenant: If `responseType` is not `id_token`, developer must provide either `clientSecret`, or `thumbprint` and `privatePEMKey`. We use `clientSecret` if it is provided; otherwise we use `thumbprint` and `privatePEMKey` for client assertion flow.\n\n  `clientSecret` is the app key of your app in AAD. For B2C, the app key sometimes contains \\, please replace \\ with two \\'s in the app key, otherwise \\ will be treated as the beginning of an escaping character.\n\n* `thumbprint`  (Conditional)\n\n  Required if you want to use client assertion flow. `thumbprint` is the base64url format of the thumbprint (hash value) of the public key.\n\n* `privatePEMKey`  (Conditional)\n\n  Required if you want to use client assertion flow. `privatePEMKey` is the private pem key string.\n\n* `isB2C`  (Conditional)\n\n  Required to set to true if you are using B2C tenant.\n\n* `validateIssuer`  (Conditional)\n  \n  Required to set to false if you don't want to validate issuer, default value is true. We validate the `iss` claim in id_token against user provided `issuer` values and the issuer value we get from tenant-specific endpoint. If you use common endpoint for `identityMetadata` and you want to validate issuer, then you have to either provide `issuer`, or provide the tenant for each login request using `tenantIdOrName` option in `passport.authenticate` (see section 5.1.3 for more details).\n  \n* `issuer`  (Conditional)\n  \n  This can be a string or an array of strings. See `validateIssuer` for the situation that requires `issuer`.\n\n* `jweKeyStore`  (Conditional)\n\n  This option is required if you want to accept and decrypt id_token in JWE Compact Serialization format. See \n  section 5.1.1.4 for more details.\n\n* `useCookieInsteadOfSession`  (Conditional)\n  \n  Passport-azure-ad saves state and nonce in session by default for validation purpose. If `useCookieInsteadOfSession` is set to true, passport-azure-ad will encrypt the state/nonce and\n  put them into cookie instead. This is helpful when we want to be completely session-free, in other words, when you use { session: false } option in passport.authenticate function.\n  If `useCookieInsteadOfSession` is set to true, you must provide `cookieEncryptionKeys` for cookie encryption and decryption.\n\n* `cookieEncryptionKeys`  (Conditional)\n\n  If `useCookieInsteadOfSession` is set to true, you must provide `cookieEncryptionKeys`. It is an array of the following format: [ {key: '...', 'iv': '...' }, {key: '...', 'iv': '...' }, ...]. key could be any string of length 32, and iv could be any string of length 12. We always use the first set of key/iv to encrypt cookie, but we try all the key/iv to decrypt cookie.\n  This is helpful if you want to do key rollover. The encryption/decryption algorithm we use is aes-256-gcm. You can limit the cookie amount and expiration using `nonceLifetime` and `nonceMaxAmount` options. \n\n* `scope`  (Optional)\n\n  List of scope values besides `openid` indicating the required scope of the access token for accessing the requested resource. For example, ['email', 'profile']. If you need refresh_token for v2 endpoint, then you have to include the 'offline_access' scope.\n\n* `loggingLevel`  (Optional)\n\n  Logging level. 'info', 'warn' or 'error'.\n\n* `loggingNoPII`  (Optional)\n\n  If this is set to true, no personal information such as tokens and claims will be logged. The default value is true.\n  \n* `nonceLifetime`  (Optional)\n  \n  The lifetime of nonce in session in seconds. The default value is 3600 seconds.\n\n* `nonceMaxAmount`  (Optional)\n  \n  The max amount of nonce you want to keep in session or cookies. The default number is 10. The oldest nonce(s) will be removed if the total number exceeds. (You can keep this number very small because nonce will be removed from session or cookies after validation. This mainly handles the case when user opens more than one login tabs at once and wants to go back to the first login page to type user credentials. Each login tab results in a nonce in session or cookie, so we only honor the most recent nonceMaxAmount many login tabs.)\n\n* `clockSkew`  (Optional)\n\n  This value is the clock skew (in seconds) allowed in token validation. It must be a positive integer. The default value is 300 seconds.\n  \n##### 5.1.1.3 Verify callback\n\nIf you set `passReqToCallback` option to false, you can use one of the following signatures for the verify callback\n\n```\n  function(iss, sub, profile, jwtClaims, access_token, refresh_token, params, done)\n  function(iss, sub, profile, access_token, refresh_token, params, done)\n  function(iss, sub, profile, access_token, refresh_token, done)\n  function(iss, sub, profile, done)\n  function(iss, sub, done)\n  function(profile, done)\n```\n\nIf you set `passReqToCallback` option to true, you can use one of the following signatures for the verify callback\n\n```\n  function(req, iss, sub, profile, jwtClaims, access_token, refresh_token, params, done)\n  function(req, iss, sub, profile, access_token, refresh_token, params, done)\n  function(req, iss, sub, profile, access_token, refresh_token, done)\n  function(req, iss, sub, profile, done)\n  function(req, iss, sub, done)\n  function(req, profile, done)\n```\n\n#### 5.1.1.4 JWE support\n\n  We support encrypted id_token in JWE Compact Serialization format. \n\n  The key encryption algorithms supported are: \n\n  `RSA1_5`, `RSA-OAEP`, `A128KW`, `A256KW`, `dir`.\n\n  The content encryption algorithms supported are:\n  \n  `A128CBC-HS256`, `A192CBC-HS384`, `A256CBC-HS512`, `A128GCM`, and `A256GCM`.\n\n  In order to decrypt the id_token, keys have to be provided in JWK format using `jweKeyStore` option. We will first\n  try the key with the corresponding kid. If decryption fails, we will try every possible key in `jweKeyStore`. \n  The following is an example of `jweKeyStore`:\n\n  ```javascript\n\n    jweKeyStore: [ \n      { 'kid': 'sym_key_256', 'kty': 'oct', 'k': 'WIVds2iwJPwNhgUgwZXmn/46Ql1EkiL+M+QqDRdQURE=' }, \n      { 'kid': 'sym_key_128', 'kty': 'oct', 'k': 'GawgguFyGrWKav7AX4VKUg'}, \n      { 'kid': 'sym_key_384', 'kty': 'oct', 'k': 'AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4v'},\n      { 'kid': 'rsa_key', \n        'kty': 'RSA', \n        \"n\":\"6-FrFkt_TByQ_L5d7or-9PVAowpswxUe3dJeYFTY0Lgq7zKI5OQ5RnSrI0\\n\\\n             T9yrfnRzE9oOdd4zmVj9txVLI-yySvinAu3yQDQou2Ga42ML_-K4Jrd5cl\\n\\\n             MUPRGMbXdV5Rl9zzB0s2JoZJedua5dwoQw0GkS5Z8YAXBEzULrup06fnB5\\n\\\n             n6x5r2y1C_8Ebp5cyE4Bjs7W68rUlyIlx1lzYvakxSnhUxSsjx7u_mIdyw\\n\\\n             yGfgiT3tw0FsWvki_KYurAPR1BSMXhCzzZTkMWKE8IaLkhauw5MdxojxyB\\n\\\n             VuNY-J_elq-HgJ_dZK6g7vMNvXz2_vT-SykIkzwiD9eSI9UWfsjw\",\n        \"e\":\"AQAB\",\n        \"d\":\"C6EGZYf9U6RI5Z0BBoSlwy_gKumVqRx-dBMuAfPM6KVbwIUuSJKT3ExeL5\\n\\\n             P0Ky1b4p-j2S3u7Afnvrrj4HgVLnC1ks6rEOc2ne5DYQq8szST9FMutyul\\n\\\n             csNUKLOM5cVromALPz3PAqE2OCLChTiQZ5XZ0AiH-KcG-3hKMa-g1MVnGW\\n\\\n             -SSmm27XQwRtUtFQFfxDuL0E0fyA9O9ZFBV5201ledBaLdDcPBF8cHC53G\\n\\\n             m5G6FRX3QVpoewm3yGk28Wze_YvNl8U3hvbxei2Koc_b9wMbFxvHseLQrx\\n\\\n             vFg_2byE2em8FrxJstxgN7qhMsYcAyw1qGJY-cYX-Ab_1bBCpdcQ\",\n        \"p\":\"_avCCyuo7hHlqu9Ec6R47ub_Ul_zNiS-xvkkuYwW-4lNnI66A5zMm_BOQV\\n\\\n             MnaCkBua1OmOgx7e63-jHFvG5lyrhyYEmkA2CS3kMCrI-dx0fvNMLEXInP\\n\\\n             xd4np_7GUd1_XzPZEkPxBhqf09kqryHMj_uf7UtPcrJNvFY-GNrzlJk\",\n        \"q\":\"7gvYRkpqM-SC883KImmy66eLiUrGE6G6_7Y8BS9oD4HhXcZ4rW6JJKuBzm\\n\\\n             7FlnsVhVGro9M-QQ_GSLaDoxOPQfHQq62ERt-y_lCzSsMeWHbqOMci_pbt\\n\\\n             vJknpMv4ifsQXKJ4Lnk_AlGr-5r5JR5rUHgPFzCk9dJt69ff3QhzG2c\",\n        \"dp\":\"ErP3OpudePAY3uGFSoF16Sde69PnOra62jDEZGnPx_v3nPNpA5sr-tNc8\\n\\\n              bQP074yQl5kzSFRjRlstyW0TpBVMP0ocbD8RsN4EKsgJ1jvaSIEoP87Ox\\n\\\n              duGkim49wFA0Qxf_NyrcYUnz6XSidY3lC_pF4JDJXg5bP_x0MUkQCTtQE\",\n        \"dq\":\"YbBsthPt15Pshb8rN8omyfy9D7-m4AGcKzqPERWuX8bORNyhQ5M8JtdXc\\n\\\n              u8UmTez0j188cNMJgkiN07nYLIzNT3Wg822nhtJaoKVwZWnS2ipoFlgrB\\n\\\n              gmQiKcGU43lfB5e3qVVYUebYY0zRGBM1Fzetd6Yertl5Ae2g2CakQAcPs\",\n        \"qi\":\"lbljWyVY-DD_Zuii2ifAz0jrHTMvN-YS9l_zyYyA_Scnalw23fQf5WIcZ\\n\\\n              ibxJJll5H0kNTIk8SCxyPzNShKGKjgpyZHsJBKgL3iAgmnwk6k8zrb_lq\\n\\\n              a0sd1QWSB-Rqiw7AqVqvNUdnIqhm-v3R8tYrxzAqkUsGcFbQYj4M5_F_4\"\n      },\n      { 'kid': 'ras_key_2',\n        'kty': 'RSA',\n        'privatePemKey': \n          '-----BEGIN RSA PRIVATE KEY-----\\n\\\n          MIIEowIBAAKCAQEA6+FrFkt/TByQ/L5d7or+9PVAowpswxUe3dJeYFTY0Lgq7zKI\\n\\\n          5OQ5RnSrI0T9yrfnRzE9oOdd4zmVj9txVLI+yySvinAu3yQDQou2Ga42ML/+K4Jr\\n\\\n          d5clMUPRGMbXdV5Rl9zzB0s2JoZJedua5dwoQw0GkS5Z8YAXBEzULrup06fnB5n6\\n\\\n          x5r2y1C/8Ebp5cyE4Bjs7W68rUlyIlx1lzYvakxSnhUxSsjx7u/mIdywyGfgiT3t\\n\\\n          w0FsWvki/KYurAPR1BSMXhCzzZTkMWKE8IaLkhauw5MdxojxyBVuNY+J/elq+HgJ\\n\\\n          /dZK6g7vMNvXz2/vT+SykIkzwiD9eSI9UWfsjwIDAQABAoIBAAuhBmWH/VOkSOWd\\n\\\n          AQaEpcMv4CrplakcfnQTLgHzzOilW8CFLkiSk9xMXi+T9CstW+Kfo9kt7uwH5766\\n\\\n          4+B4FS5wtZLOqxDnNp3uQ2EKvLM0k/RTLrcrpXLDVCizjOXFa6JgCz89zwKhNjgi\\n\\\n          woU4kGeV2dAIh/inBvt4SjGvoNTFZxlvkkpptu10MEbVLRUBX8Q7i9BNH8gPTvWR\\n\\\n          QVedtNZXnQWi3Q3DwRfHBwudxpuRuhUV90FaaHsJt8hpNvFs3v2LzZfFN4b28Xot\\n\\\n          iqHP2/cDGxcbx7Hi0K8bxYP9m8hNnpvBa8SbLcYDe6oTLGHAMsNahiWPnGF/gG/9\\n\\\n          WwQqXXECgYEA/avCCyuo7hHlqu9Ec6R47ub/Ul/zNiS+xvkkuYwW+4lNnI66A5zM\\n\\\n          m/BOQVMnaCkBua1OmOgx7e63+jHFvG5lyrhyYEmkA2CS3kMCrI+dx0fvNMLEXInP\\n\\\n          xd4np/7GUd1/XzPZEkPxBhqf09kqryHMj/uf7UtPcrJNvFY+GNrzlJkCgYEA7gvY\\n\\\n          RkpqM+SC883KImmy66eLiUrGE6G6/7Y8BS9oD4HhXcZ4rW6JJKuBzm7FlnsVhVGr\\n\\\n          o9M+QQ/GSLaDoxOPQfHQq62ERt+y/lCzSsMeWHbqOMci/pbtvJknpMv4ifsQXKJ4\\n\\\n          Lnk/AlGr+5r5JR5rUHgPFzCk9dJt69ff3QhzG2cCgYASs/c6m5148Bje4YVKgXXp\\n\\\n          J17r0+c6trraMMRkac/H+/ec82kDmyv601zxtA/TvjJCXmTNIVGNGWy3JbROkFUw\\n\\\n          /ShxsPxGw3gQqyAnWO9pIgSg/zs7F24aSKbj3AUDRDF/83KtxhSfPpdKJ1jeUL+k\\n\\\n          XgkMleDls//HQxSRAJO1AQKBgGGwbLYT7deT7IW/KzfKJsn8vQ+/puABnCs6jxEV\\n\\\n          rl/GzkTcoUOTPCbXV3LvFJk3s9I9fPHDTCYJIjdO52CyMzU91oPNtp4bSWqClcGV\\n\\\n          p0toqaBZYKwYJkIinBlON5XweXt6lVWFHm2GNM0RgTNRc3rXemHq7ZeQHtoNgmpE\\n\\\n          AHD7AoGBAJW5Y1slWPgw/2bootonwM9I6x0zLzfmEvZf88mMgP0nJ2pcNt30H+Vi\\n\\\n          HGYm8SSZZeR9JDUyJPEgscj8zUoShio4KcmR7CQSoC94gIJp8JOpPM62/5amtLHd\\n\\\n          UFkgfkaosOwKlarzVHZyKoZvr90fLWK8cwKpFLBnBW0GI+DOfxf+\\n\\\n          -----END RSA PRIVATE KEY-----\\n';\n      }\n  ]\n\n  ```\n\n\n#### 5.1.2 Use `passport.authenticate` to protect routes\n\nTo complete the sample, provide a route that corresponds to the path \nconfiguration parameter that is sent to the strategy:\n\n```javascript\n\napp.get('/login', \n  passport.authenticate('azuread-openidconnect', { failureRedirect: '/' }),\n  function(req, res) {\n    log.info('Login was called in the Sample');\n    res.redirect('/');\n});\n\n// POST /auth/openid/return\n//   Use passport.authenticate() as route middleware to authenticate the\n//   request.  If authentication fails, the user will be redirected back to the\n//   home page.  Otherwise, the primary route function function will be called,\n//   which, in this example, will redirect the user to the home page.\napp.post('/auth/openid/return',\n  passport.authenticate('azuread-openidconnect', { failureRedirect: '/' }),\n  function(req, res) { \n    res.redirect('/');\n  });\n\napp.get('/logout', function(req, res){\n  req.logout();\n  res.redirect('/');\n});\n\n```\n\n#### 5.1.3 Options available for `passport.authenticate`\n\n* `failureRedirect`: the url redirected to when the authentication fails\n\n* `session`: if you don't want a persistent login session, you can use `session: false`. The default value is true.\n\n* `customState`: if you want to use a custom state value instead of a random generated one\n\n* `resourceURL`: if you need access_token for some resource. Note this option is only for v1 endpoint and `code`, `code id_token`, `id_token code` flow. For v2 endpoint, resource is considered as a scope, so it should be specified in the `scope` field when you create\nthe strategy.\n\n* `tenantIdOrName`: if you want to specify the tenant to use for this request. You can use the tenant guid or tenant name (like 'contoso.onmicrosoft.com'). Note: \n  * You must use common endpoint for `identityMetadata`, otherwise this option will be ignored. We will fetch and use the metadata from the tenant you specify for this request.\n  * This option only applies to the login request, in other words, the request which is not supposed to contain code or id_token. Passport saves the `tenantIdOrName` value in session before sending the authentication request. When we receive a request containing code or id_token, we retrieve the saved `tenantIdOrName` value from session and use that value.\n  * If you are using B2C common endpoint, then `tenantIdOrName` must be used for every login request.\n\n* `domain_hint`: if you want to specify the domain that the user should use to sign in. This option is not supported for B2C tenant.\n\n* `login_hint`: if you want to prefill the username with a given value in the login page. The value should be the `upn` of a user, not the email (most times they are the same though). \n\n* `prompt`: v1 and v2 endpoint support `login`, `consent` and `admin_consent`; B2C endpoint only supports `login`. \n\n* `response`: this is required if you want to use cookie instead of session to save state/nonce. See section 5.1.4.\n\nExample:\n\n```\n  passport.authenticate('azuread-openidconnect', { failureRedirect: '/', session: false, customState: 'my_state', resourceURL: 'https://graph.microsoft.com/mail.send'});\n  \n  passport.authenticate('azuread-openidconnect', { tenantIdOrName: 'contoso.onmicrosoft.com' });\n```\n\n#### 5.1.4 Session free support\n\nPassport framework uses session to keep a persistent login session. As a plug in, we also use session to store state and nonce by default, regardless whether you use { session: false } option in passport.authenticate or not. To be completely session free, you must configure passport-azure-ad to create state/nonce cookie instead of saving them in session. Please follow the following example:\n\n```\n  passport.use(new OIDCStrategy({\n    ...\n    nonceLifetime: 600,  // state/nonce cookie expiration in seconds\n    nonceMaxAmount: 5,   // max amount of state/nonce cookie you want to keep (cookie is deleted after validation so this can be very small)\n    useCookieInsteadOfSession: true,  // use cookie, not session\n    cookieEncryptionKeys: [ { key: '12345678901234567890123456789012', 'iv': '123456789012' }],  // encrypt/decrypt key and iv, see `cookieEncryptionKeys` instruction in section 5.1.1.2\n  },\n    // any supported verify callback\n    function(iss, sub, profile, accessToken, refreshToken, done) {\n    ...\n  });\n\n  app.get('/login', passport.authenticate('azuread-openidconnect', { session: false }));\n\n```\n\n### 5.2 BearerStrategy\n\n#### 5.2.1 Configure strategy and provide callback function\n\n##### 5.2.1.1 Sample using the BearerStrategy\n\n```javascript\n\n// We pass these options in to the ODICBearerStrategy.\n\nvar options = {\n  identityMetadata: config.creds.identityMetadata,\n  clientID: config.creds.clientID,\n  validateIssuer: config.creds.validateIssuer,\n  issuer: config.creds.issuer,\n  passReqToCallback: config.creds.passReqToCallback,\n  isB2C: config.creds.isB2C,\n  policyName: config.creds.policyName,\n  allowMultiAudiencesInToken: config.creds.allowMultiAudiencesInToken,\n  audience: config.creds.audience,\n  loggingLevel: config.creds.loggingLevel,\n  loggingNoPII: config.creds.loggingNoPII,\n  clockSkew: config.creds.clockSkew,\n  scope: config.creds.scope\n};\n\nvar bearerStrategy = new BearerStrategy(options,\n  function(token, done) {\n    log.info('verifying the user');\n    log.info(token, 'was the token retreived');\n    findById(token.oid, function(err, user) {\n      if (err) {\n        return done(err);\n      }\n      if (!user) {\n        // \"Auto-registration\"\n        log.info('User was added automatically as they were new. Their oid is: ', token.oid);\n        users.push(token);\n        owner = token.oid;\n        return done(null, token);\n      }\n      owner = token.oid;\n      return done(null, user, token);\n    });\n  }\n);\n``` \n\n##### 5.2.1.2 Options\n\n* `identityMetadata` (Required)\n\n  The metadata endpoint provided by the Microsoft Identity Portal that provides the keys and other important information at runtime.    Examples:\n  * v1 tenant-specific endpoint\n  ```\n    https://login.microsoftonline.com/your_tenant_name.onmicrosoft.com/.well-known/openid-configuration\n    https://login.microsoftonline.com/your_tenant_guid/.well-known/openid-configuration\n  ```\n  * v1 common endpoint\n  ```\n    https://login.microsoftonline.com/common/.well-known/openid-configuration\n  ```\n  * v2 tenant-specific endpoint\n  ```\n    https://login.microsoftonline.com/your_tenant_name.onmicrosoft.com/v2.0/.well-known/openid-configuration \n    https://login.microsoftonline.com/your_tenant_guid/v2.0/.well-known/openid-configuration\n  ```\n  * v2 common endpoint\n  ``` \n    https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration\n  ```\n  \n  For B2C, you can only use v2 tenant-specific endpoint.\n  \n* `clientID` (Required)\n\n  The client ID of your application in AAD (Azure Active Directory)\n\n* `passReqToCallback`  (Required)\n\n  Whether you want to use `req` as the first parameter in the verify callback. See section 5.2.1.3 for more details.\n  \n* `isB2C`  (Conditional)\n\n  Required to set to true if you are using B2C tenant.\n  \n* `policyName`  (Conditional)\n\n  Required if you are using B2C tenant. It is a string starting with 'B2C_1_' (case insensitive).\n\n* `validateIssuer`  (Conditional)\n  \n  Required to set to false if you don't want to validate issuer, default value is true. We validate the `iss` claim in id_token against user provided `issuer` values and the issuer value we get from tenant-specific endpoint. If you use common endpoint for `identityMetadata` and you want to validate issuer, then you must provide `issuer`, or provide `tenantIdOrName` in passport.authenticate.\n  \n* `issuer`  (Conditional)\n  \n  This can be a string or an array of strings. See `validateIssuer` for the situation that requires `issuer`.\n  \n* `allowMultiAudiencesInToken`  (Conditional)\n\n  Required if you allow access_token whose `aud` claim contains multiple values.\n\n* `scope`  (Optional)\n\n  This value is an array of scopes you accept. If this value is provided, we will check if the token contains one of\n  these accepted scopes. If this value is not provided, we won't check token scopes.\n  \n* `audience`  (Optional)\n\n  Must be a string or an array of strings. We invalidate the `aud` claim in access_token against `audience`. The default value for `audience` is `clientID`.\n  \n* `loggingLevel`  (Optional)\n\n  Logging level. 'info', 'warn' or 'error'.\n\n* `loggingNoPII`  (Optional)\n\n  If this is set to true, no personal information such as tokens and claims will be logged. The default value is true.\n\n* `clockSkew`  (Optional)\n\n  This value is the clock skew (in seconds) allowed in token validation. It must be a positive integer. The default value is 300 seconds.\n\n##### 5.2.1.3 Verify callback\n\nIf you set `passReqToCallback` option to false, you can use the following verify callback\n\n```\n  function(token, done)\n```\n\nIf you set `passReqToCallback` option to true, you can use the following verify callback\n\n```\n  function(req, token, done)\n```\n\n#### 5.2.2 Use `passport.authenticate` to protect resources or APIs\n\nIn the following example, we are using passport to protect '/api/tasks'. User sends a GET request to '/api/tasks' with access_token in authorization header or body. Passport validates the access_token, adds the related claims from access_token to `req.user`, and passes the request to listTasks middleware. The listTasks middleware can then read the user information in `req.user` and list all the tasks related to this user. Note that we do authentication every time, so we don't need to keep this user in session, and this can be achieved  by using `session: false` option.\n\n```javascript\n  server.get('/api/tasks', passport.authenticate('oauth-bearer', { session: false }), listTasks);\n```\n\n#### 5.2.3 Options available for `passport.authenticate`\n\n* `session`: if you don't want a persistent login session, you can use `session: false`. The default value is true.\n\n* `tenantIdOrName`: if you use common endpoint, you can use this option to dynamically provide the tenant.\n\nExample:\n\n```\n  passport.authenticate('oauth-bearer', { session: false });\n```\n\n## 6. Test\n\nIn the library root folder, type the following command to install the dependency packages:\n\n```\n    $ npm install\n```\n\n### 6.1. Run all tests except the end to end tests\n\nType the following command to run tests:\n\n```\n    $ npm test\n```\n\n### 6.2. Run all tests including the end to end tests\n\n#### 6.2.1. Create test applications\n\nFirst you need to register one application in v1 tenant, one in v2 tenant and one in B2C tenant. \n\nFor the v2 application, you should register it at https://apps.dev.microsoft.com/ instead of Azure Portal.\n\nFor the B2C application, create policies named 'B2C_1_signin', 'B2C_1_signup'. For each policy, select 'Local Account' as the identity provider, and select the\nfollowing:\n\n* 'B2C_1_signup': \n\n  * Sign-up attributes: 'Display Name', 'Email Address', 'Given Name', 'Surname'\n\n  * Application claims: 'Display Name', Email Addresses', 'Given Name', 'Identity Provider', 'Surname', 'Users Object ID'\n\n* 'B2C_1_signin': \n\n  * Application claims: 'Display Name', Email Addresses', 'Given Name', 'Identity Provider', 'Surname', 'Users Object ID'\n\nYou will also need to click the 'Run now' button in the 'B2C_1_signup' blade to create an user.\n\nFor B2C application, you will also need to create at least one scope and provide it to test parameters. See [how to create scope for B2C access token](https://azure.microsoft.com/en-us/blog/azure-ad-b2c-access-tokens-now-in-public-preview/). In the bearer_b2c_test, We will use OIDCStrategy to get a B2C\naccess token for the scope, and use BearerStrategy to validate the scope. Note for scope we use the full url in\n `b2c_params.scopeForOIDC` but only the name in `b2c_params.scopeForBearer`. For example, \n `b2c_params.scopeForOIDC=['https://sijun1b2c.onmicrosoft.com/oidc-b2c/read']` and `b2c_params.scopeForBearer=['read']`. \n\n#### 6.2.2. Fill the test parameters \n\nOpen `test/End_to_end_test/script.js`, set `is_test_parameters_completed` parameter to true. For `test_parameters` variable, fill in the tenant id/client id/client secret of your applications, and the username/password of your application user. \n\nFor `thumbprint` and `privatePEMKey` parameters, you need to specify a certificate for your app and register the public key in Azure Active Directory. `thumbprint` is the base64url format of the thumbprint of the public key, and `privatePEMKey` is the private pem key string. For a v1 tenant, you can follow [this post](http://www.andrewconnell.com/blog/user-app-app-only-permissions-client-credentials-grant-flow-in-azure-ad-office-365-apis) to generate a certificate and register the public key. For a v2 tenant, you can go to your application page in the [v2 portal](https://apps.dev.microsoft.com) and click `Generate New Key Pair`. A certificate will be generated for you to download. The corresponding public key is automatically registered in this case.  \n\n#### 6.2.3. Run the tests\n\nType the following commands to run the tests:\n\n```\n    $ cd test/End_to_end_test\n    $ npm install\n    $ npm install grunt -g\n    $ grunt run_tests_with_e2e\n```\n\nTests will run automatically and in the terminal you can see how many tests are passing/failing. More details can be found [here](https://github.com/AzureAD/passport-azure-ad/blob/master/contributing.md).\n\n## 7. Samples and Documentation\n\n[We provide a full suite of sample applications and documentation on GitHub](https://azure.microsoft.com/en-us/documentation/samples/?service=active-directory) \nto help you get started with learning the Azure Identity system. This includes \ntutorials for native clients such as Windows, Windows Phone, iOS, OSX, Android, \nand Linux. We also provide full walkthroughs for authentication flows such as \nOAuth2, OpenID Connect, Graph API, and other awesome features. \n\nAzure Identity samples for this plug-in can be found in the following links:\n\n### 7.1 Samples for [OpenID connect strategy](https://github.com/AzureAD/passport-azure-ad/blob/master/lib/oidcstrategy.js)\n\n* [sample using v1 endpoint](https://github.com/AzureADQuickStarts/WebApp-OpenIDConnect-NodeJS)\n\n* [sample using v2 endpoint](https://github.com/AzureADQuickStarts/AppModelv2-WebApp-OpenIDConnect-nodejs)\n\n* [sample using B2C tenant](https://github.com/AzureADQuickStarts/B2C-WebApp-OpenIDConnect-NodeJS)\n\n### 7.2 Samples for [Bearer strategy](https://github.com/AzureAD/passport-azure-ad/blob/master/lib/bearerstrategy.js)\n\n* [sample using v1 endpoint](https://github.com/AzureADQuickStarts/WebAPI-Bearer-NodeJS)\n\n* [sample using v2 endpoint](https://github.com/AzureADQuickStarts/AppModelv2-WebAPI-nodejs)\n\n* [sample using B2C tenant](https://github.com/AzureADQuickStarts/B2C-WebApi-Nodejs)\n\n## 8. Community Help and Support\n\nWe leverage [Stack Overflow](http://stackoverflow.com/) to work with the community on supporting Azure Active Directory and its SDKs, including this one. We highly recommend you ask your questions on Stack Overflow (we're all on there!) Also browser existing issues to see if someone has had your question before. \n\nWe recommend you use the \"adal\" tag so we can see it! Here is the latest Q&A on Stack Overflow for ADAL: [http://stackoverflow.com/questions/tagged/adal](http://stackoverflow.com/questions/tagged/adal)\n\n## 9. Security Reporting\n\nIf you find a security issue with our libraries or services please report it to [secure@microsoft.com](mailto:secure@microsoft.com) with as much detail as possible. Your submission may be eligible for a bounty through the [Microsoft Bounty](http://aka.ms/bugbounty) program. Please do not post security issues to GitHub Issues or any other public site. We will contact you shortly upon receiving the information. We encourage you to get notifications of when security incidents occur by visiting [this page](https://technet.microsoft.com/en-us/security/dd252948) and subscribing to Security Advisory Alerts.\n\n## 10. Contributing\n\nAll code is licensed under the MIT license and we triage actively on GitHub. We enthusiastically welcome contributions and feedback. You can clone the repo and start contributing now. \n\nMore details [about contribution](https://github.com/AzureAD/passport-azure-ad/blob/master/contributing.md) \n\n## 11. Releases\n\nPlease check the [releases](https://github.com/AzureAD/passport-azure-ad/releases) for updates.\n\n## 12. Acknowledgements\n\nThe code is based on Henri Bergius's [passport-saml](https://github.com/bergie/passport-saml) library and Matias Woloski's [passport-wsfed-saml2](https://github.com/auth0/passport-wsfed-saml2) library as well as Kiyofumi Kondoh's [passport-openid-google](https://github.com/kkkon/passport-google-openidconnect).\n\n## 13. License\nCopyright (c) Microsoft Corp.  All rights reserved. Licensed under the MIT License;\n\n## 14. Microsoft Open Source Code of Conduct\n\nWe Value and Adhere to the Microsoft Open Source Code of Conduct\n\nThis project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/). For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/AzureAD/passport-azure-ad.git"
  },
  "scripts": {
    "test": "grunt run_tests"
  },
  "version": "3.0.12"
}
